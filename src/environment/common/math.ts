import * as symbolic from '../symbolic';

export const MathObj = new symbolic.SymbolicNamespace({
    E: symbolic.value({ value: Math.E }),
    LN10: symbolic.value({ value: Math.LN10 }),
    LN2: symbolic.value({ value: Math.LN2 }),
    LOG10E: symbolic.value({ value: Math.LOG10E }),
    LOG2E: symbolic.value({ value: Math.LOG2E }),
    PI: symbolic.value({ value: Math.PI }),
    SQRT1_2: symbolic.value({ value: Math.SQRT1_2 }),
    SQRT2: symbolic.value({ value: Math.SQRT2 }),
    abs: symbolic.func({ compTime: symbolic.concreteWrapper(Math.abs) }),
    acos: symbolic.func({ compTime: symbolic.concreteWrapper(Math.acos) }),
    acosh: symbolic.func({ compTime: symbolic.concreteWrapper(Math.acosh) }),
    asin: symbolic.func({ compTime: symbolic.concreteWrapper(Math.asin) }),
    asinh: symbolic.func({ compTime: symbolic.concreteWrapper(Math.asinh) }),
    atan: symbolic.func({ compTime: symbolic.concreteWrapper(Math.atan) }),
    atan2: symbolic.func({ compTime: symbolic.concreteWrapper(Math.atan2) }),
    atanh: symbolic.func({ compTime: symbolic.concreteWrapper(Math.atanh) }),
    cbrt: symbolic.func({ compTime: symbolic.concreteWrapper(Math.cbrt) }),
    ceil: symbolic.func({ compTime: symbolic.concreteWrapper(Math.ceil) }),
    clz32: symbolic.func({ compTime: symbolic.concreteWrapper(Math.clz32) }),
    cos: symbolic.func({ compTime: symbolic.concreteWrapper(Math.cos) }),
    cosh: symbolic.func({ compTime: symbolic.concreteWrapper(Math.cosh) }),
    exp: symbolic.func({ compTime: symbolic.concreteWrapper(Math.exp) }),
    expm1: symbolic.func({ compTime: symbolic.concreteWrapper(Math.expm1) }),
    floor: symbolic.func({ compTime: symbolic.concreteWrapper(Math.floor) }),
    fround: symbolic.func({ compTime: symbolic.concreteWrapper(Math.fround) }),
    hypot: symbolic.func({ compTime: symbolic.concreteWrapper(Math.hypot) }),
    imul: symbolic.func({ compTime: symbolic.concreteWrapper(Math.imul) }),
    log: symbolic.func({ compTime: symbolic.concreteWrapper(Math.log) }),
    log10: symbolic.func({ compTime: symbolic.concreteWrapper(Math.log10) }),
    log1p: symbolic.func({ compTime: symbolic.concreteWrapper(Math.log1p) }),
    log2: symbolic.func({ compTime: symbolic.concreteWrapper(Math.log2) }),
    max: symbolic.func({ compTime: symbolic.concreteWrapper(Math.max) }),
    min: symbolic.func({ compTime: symbolic.concreteWrapper(Math.min) }),
    pow: symbolic.func({ compTime: symbolic.concreteWrapper(Math.pow) }),
    random: symbolic.func({ compTime: symbolic.concreteWrapper(Math.random) }),
    round: symbolic.func({ compTime: symbolic.concreteWrapper(Math.round) }),
    sign: symbolic.func({ compTime: symbolic.concreteWrapper(Math.sign) }),
    sin: symbolic.func({ compTime: symbolic.concreteWrapper(Math.sin) }),
    sinh: symbolic.func({ compTime: symbolic.concreteWrapper(Math.sinh) }),
    sqrt: symbolic.func({ compTime: symbolic.concreteWrapper(Math.sqrt) }),
    tan: symbolic.func({ compTime: symbolic.concreteWrapper(Math.tan) }),
    tanh: symbolic.func({ compTime: symbolic.concreteWrapper(Math.tanh) }),
    trunc: symbolic.func({ compTime: symbolic.concreteWrapper(Math.trunc) }),
});
